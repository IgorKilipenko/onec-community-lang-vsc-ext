{
  "name": "1C:Community",
  "scopeName": "source.bsl",
  "fileTypes": ["bsl", "os"],
  "patterns": [
    {
      "include": "#directives__"
    },
    {
      "include": "#statements__"
    },
    {
      "include": "#shebang__"
    },
    {
      "include": "#function-declaration"
    }
  ],
  "repository": {
    "statements": {
      "patterns": [
        {
          "include": "#declaration"
        },
        {
          "include": "#control-statement"
        },
        {
          "include": "#after-operator-block-as-object-literal"
        },
        {
          "include": "#decl-block"
        },
        {
          "include": "#label"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-semicolon"
        },
        {
          "include": "#string"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "expression": {
			"patterns": [
				{
					"include": "#expressionWithoutIdentifiers__"
				},
				{
					"include": "#identifiers"
				},
				{
					"include": "#expressionPunctuations__"
				}
			]
		},
    "declaration": {
      "patterns": [
        {
          "include": "#decorator"
        },
        {
          "include": "#var-declaration"
        },
        {
          "include": "#function-declaration"
        },
        {
          "include": "#class-declaration"
        },
        {
          "include": "#interface-declaration"
        },
        {
          "include": "#enum-declaration"
        },
        {
          "include": "#namespace-declaration"
        },
        {
          "include": "#type-alias-declaration"
        },
        {
          "include": "#import-equals-declaration"
        },
        {
          "include": "#import-declaration"
        },
        {
          "include": "#export-declaration"
        }
      ]
    },
    "punctuation-comma": {
      "name": "punctuation.separator.comma.bsl",
      "match": ","
    },
    "punctuation-semicolon": {
      "name": "punctuation.terminator.statement.bsl",
      "match": ";"
    },
    "identifiers": {
      "patterns": [
        {
          "include": "#object-identifiers"
        },
        {
          "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])",
          "captures": {
            "1": {
              "name": "punctuation.accessor.bsl"
            },
            "2": {
              "name": "punctuation.accessor.optional.bsl"
            },
            "3": {
              "name": "variable.other.constant.property.bsl"
            }
          }
        },
        {
          "match": "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)",
          "captures": {
            "1": {
              "name": "punctuation.accessor.bsl"
            },
            "2": {
              "name": "punctuation.accessor.optional.bsl"
            },
            "3": {
              "name": "variable.other.property.bsl"
            }
          }
        },
        {
          "name": "variable.other.constant.bsl",
          "match": "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
        },
        {
          "name": "variable.other.readwrite.bsl",
          "match": "[_$[:alpha:]][_$[:alnum:]]*"
        }
      ]
    },
    "object-identifiers": {
      "patterns": [
        {
          "name": "support.class.bsl",
          "match": "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))"
        },
        {
          "match": "(\\.)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=\\()",
          "captures": {
            "1": {
              "name": "punctuation.accessor.bsl"
            },
            "2": {
              "name": "entity.name.function.bsl"
            }
          }
        },
        {
          "match": "(\\.)([_$[:alpha:]][_$[:alnum:]]*)\\s*(?!\\()",
          "captures": {
            "1": {
              "name": "punctuation.accessor.bsl"
            },
            "2": {
              "name": "entity.name.function.bsl"
            }
          }
        },
        {
          "match": "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
          "captures": {
            "1": {
              "name": "variable.other.constant.object.bsl"
            },
            "2": {
              "name": "variable.other.object.bsl"
            }
          }
        }
      ]
    },
    "function-declaration": {
      "name": "meta.function.bsl",
      "begin": "^\\s*(Процедура|Функция)\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*",
      "beginCaptures": {
        "1": {
          "name": "storage.type.function.bsl"
        },
        "2": {
          "name": "meta.definition.function.bsl entity.name.function.bsl"
        }
      },
      "end": "^\\s*(Конец(?:Процедуры|Функции))[\\s;]*$",
      "endCaptures": {
        "1": {
          "name": "storage.type.function.bsl"
        }
      },
      "patterns": [
        {
          "include": "#function-body"
        }
      ]
    },
    "function-name": {
      "patterns": [
        {
          "match": "(\\.)([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=\\()",
          "captures": {
            "1": {
              "name": "punctuation.accessor.bsl"
            },
            "2": {
              "name": "entity.name.function.bsl"
            }
          }
        }
      ]
    },
    "function-body": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#type-parameters__"
        },
        {
          "include": "#function-parameters__"
        },
        {
          "include": "#function-export"
        },
        {
          "include": "#return-type__"
        },
        {
          "include": "#type-function-return-type__"
        },
        {
          "include": "#statements"
        },
        {
          "include": "#function-declaration"
        }
      ]
    },
    "function-export": {
      "patterns": [
        {
          "match": "\\s*((?i:\\bЭкспорт))\\s*$",
          "captures": {
            "1": {
              "name": "storage.modifier.bsl"
            }
          }
        }
      ]
    },
    "function-parameters": {
      "name": "meta.parameters.bsl",
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.parameters.begin.bsl"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.parameters.end.bsl"
        }
      },
      "patterns": [
        {
          "include": "#function-parameters-body"
        }
      ]
    },
    "function-parameters-body": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#string"
        },
        {
          "include": "#decorator"
        },
        {
          "include": "#destructuring-parameter"
        },
        {
          "include": "#parameter-name"
        },
        {
          "include": "#parameter-type-annotation"
        },
        {
          "include": "#variable-initializer"
        },
        {
          "name": "punctuation.separator.parameter.bsl",
          "match": ","
        }
      ]
    },
    "parameter-name": {
      "patterns": [
        {
          "match": "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
          "captures": {
            "1": {
              "name": "storage.modifier.bsl"
            }
          }
        },
        {
          "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*(((const\\s+)?[_$[:alpha:]])|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
          "captures": {
            "1": {
              "name": "storage.modifier.bsl"
            },
            "2": {
              "name": "keyword.operator.rest.bsl"
            },
            "3": {
              "name": "entity.name.function.bsl variable.language.this.bsl"
            },
            "4": {
              "name": "entity.name.function.bsl"
            },
            "5": {
              "name": "keyword.operator.optional.bsl"
            }
          }
        },
        {
          "match": "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)",
          "captures": {
            "1": {
              "name": "storage.modifier.bsl"
            },
            "2": {
              "name": "keyword.operator.rest.bsl"
            },
            "3": {
              "name": "variable.parameter.bsl variable.language.this.bsl"
            },
            "4": {
              "name": "variable.parameter.bsl"
            },
            "5": {
              "name": "keyword.operator.optional.bsl"
            }
          }
        }
      ]
    },
    "var-declaration": {
      "comment": "Define of variable",
      "begin": "(?i:(?<=[^\\wа-яё\\.]|^)(Перем|Var)\\s+([a-zа-яё0-9_]+)\\s*)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.var.bsl"
        },
        "2": {
          "name": "meta.definition.variable.bsl variable.other.readwrite.bsl"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.statement.bsl"
        }
      },
      "patterns": [
        {
          "name": "punctuation.separator.comma.bsl",
          "match": "(,)"
        },
        {
          "name": "storage.modifier.bsl",
          "match": "(?i:(?<=[^\\wа-яё\\.]|^)(Экспорт|Export)(?=[^\\wа-яё\\.]|$))"
        },
        {
          "name": "variable.bsl",
          "match": "(?i:[a-zа-яё0-9_]+)"
        }
      ]
    },
    "comment": {
      "patterns": [
        {
          "name": "comment.block.documentation.bsl",
          "begin": "/\\*\\*(?!/)",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.comment.bsl"
            }
          },
          "end": "\\*/",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.comment.bsl"
            }
          },
          "patterns": [
            {
              "include": "#docblock"
            }
          ]
        },
        {
          "name": "comment.block.bsl",
          "begin": "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.comment.bsl"
            },
            "2": {
              "name": "storage.type.internaldeclaration.bsl"
            },
            "3": {
              "name": "punctuation.decorator.internaldeclaration.bsl"
            }
          },
          "end": "\\*/",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.comment.bsl"
            }
          }
        },
        {
          "begin": "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.bsl"
            },
            "2": {
              "name": "comment.line.double-slash.bsl"
            },
            "3": {
              "name": "punctuation.definition.comment.bsl"
            },
            "4": {
              "name": "storage.type.internaldeclaration.bsl"
            },
            "5": {
              "name": "punctuation.decorator.internaldeclaration.bsl"
            }
          },
          "end": "(?=$)",
          "contentName": "comment.line.double-slash.bsl"
        }
      ]
    }
  }
}
